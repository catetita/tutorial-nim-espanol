% This file was generated by Nimrod.
% Generated: 2019-06-28 18:03:42 UTC
\documentclass[a4paper]{article}
\usepackage[left=2cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyvrb, courier}
\usepackage{tabularx}
\usepackage{hyperref}

\begin{document}
\title{README }
\author{}

\tolerance 1414 
\hbadness 1414 
\emergencystretch 1.5em 
\hfuzz 0.3pt 
\widowpenalty=10000 
\vfuzz \hfuzz 
\raggedbottom 

\maketitle

\newenvironment{rstpre}{\VerbatimEnvironment\begingroup\begin{Verbatim}[fontsize=\footnotesize , commandchars=\\\{\}]}{\end{Verbatim}\endgroup}

% to pack tabularx into a new environment, special syntax is needed :-(
\newenvironment{rsttab}[1]{\tabularx{\linewidth}{#1}}{\endtabularx}

\newcommand{\rstsub}[1]{\raisebox{-0.5ex}{\scriptsize{#1}}}
\newcommand{\rstsup}[1]{\raisebox{0.5ex}{\scriptsize{#1}}}

\newcommand{\rsthA}[1]{\section{#1}}
\newcommand{\rsthB}[1]{\subsection{#1}}
\newcommand{\rsthC}[1]{\subsubsection{#1}}
\newcommand{\rsthD}[1]{\paragraph{#1}}
\newcommand{\rsthE}[1]{\paragraph{#1}}

\newcommand{\rstovA}[1]{\section*{#1}}
\newcommand{\rstovB}[1]{\subsection*{#1}}
\newcommand{\rstovC}[1]{\subsubsection*{#1}}
\newcommand{\rstovD}[1]{\paragraph*{#1}}
\newcommand{\rstovE}[1]{\paragraph*{#1}}

% Syntax highlighting:
\newcommand{\spanDecNumber}[1]{#1}
\newcommand{\spanBinNumber}[1]{#1}
\newcommand{\spanHexNumber}[1]{#1}
\newcommand{\spanOctNumber}[1]{#1}
\newcommand{\spanFloatNumber}[1]{#1}
\newcommand{\spanIdentifier}[1]{#1}
\newcommand{\spanKeyword}[1]{\textbf{#1}}
\newcommand{\spanStringLit}[1]{#1}
\newcommand{\spanLongStringLit}[1]{#1}
\newcommand{\spanCharLit}[1]{#1}
\newcommand{\spanEscapeSequence}[1]{#1}
\newcommand{\spanOperator}[1]{#1}
\newcommand{\spanPunctuation}[1]{#1}
\newcommand{\spanComment}[1]{\emph{#1}}
\newcommand{\spanLongComment}[1]{\emph{#1}}
\newcommand{\spanRegularExpression}[1]{#1}
\newcommand{\spanTagStart}[1]{#1}
\newcommand{\spanTagEnd}[1]{#1}
\newcommand{\spanKey}[1]{#1}
\newcommand{\spanValue}[1]{#1}
\newcommand{\spanRawData}[1]{#1}
\newcommand{\spanAssembler}[1]{#1}
\newcommand{\spanPreprocessor}[1]{#1}
\newcommand{\spanDirective}[1]{#1}
\newcommand{\spanCommand}[1]{#1}
\newcommand{\spanRule}[1]{#1}
\newcommand{\spanHyperlink}[1]{#1}
\newcommand{\spanLabel}[1]{#1}
\newcommand{\spanReference}[1]{#1}
\newcommand{\spanOther}[1]{#1}
\newcommand{\spantok}[1]{\frame{#1}}

\rsthA{\textbf{Tutorial de Nim}}\label{tutorial-de-nim}
\includegraphics{https://raw.githubusercontent.com/catetita/tutorial-nim-espanol/master/img.png}\rsthB{Introducción}\label{introducción}
Este documento es un tutorial para el lenguaje de programación Nim. Este tutorial asume que está familiarizado con los conceptos básicos de programación, como variables, tipos o declaraciones, pero se mantiene muy básico. El manual contiene muchos más ejemplos de las características avanzadas del lenguaje. Todos los ejemplos de código en este tutorial, así como los que se encuentran en el resto de la documentación de Nim, siguen la guía de estilo de Nim .

\rsthB{El primer programa}\label{el-primer-programa}
Comenzamos el recorrido con un programa modificado "hola mundo":

\begin{rstpre}
\spanComment{\# This is a comment}
\spanIdentifier{echo} \spanStringLit{"What's your name? "}
\spanKeyword{var} \spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{stdin}\spanPunctuation{)}
\spanIdentifier{echo} \spanStringLit{"Hi, "}\spanPunctuation{,} \spanIdentifier{name}\spanPunctuation{,} \spanStringLit{"!"}
\end{rstpre}
\rsthB{Elementos léxicos}\label{elementos-léxicos}
Veamos los elementos léxicos de Nim con más detalle: al igual que otros lenguajes de programación, Nim consta de literales (de cadena), identificadores, palabras clave, comentarios, operadores y otros signos de puntuación.

\textbf{Literales de cuerdas y personajes}

\begin{itemize}\item Los literales de cadena están encerrados entre comillas dobles;
\end{itemize}
Literales de caracteres en comillas simples. Los caracteres especiales se escapan con \texttt{\symbol{92}}, \texttt{\symbol{92}n} significa nueva línea, \texttt{\symbol{92}t} significa tabulador, etc. También hay literales de cadena en bruto.

\begin{rstpre}
\spanRawData{r"C:\symbol{92}program files\symbol{92}nim""}
\end{rstpre}
\begin{itemize}\item En literales crudos, la barra invertida no es un personaje de escape.
\end{itemize}
La tercera y última forma de escribir literales de cadena son literales de cadena larga. Están escritos con tres citas: \texttt{"""..."""}; Pueden abarcar varias líneas y el\symbol{96}\symbol{96}\symbol{96}\symbol{96} no es un carácter de escape tampoco. Son muy útiles para incrustar plantillas de código HTML, por ejemplo.

\textbf{Comentarios}

Los comentarios comienzan en cualquier lugar fuera de una cadena o literal de caracteres con el \texttt{\#} de carácter de hash. Los comentarios de documentación comienzan con \texttt{\#\#}:

\begin{rstpre}
\spanComment{\# A comment.}
\spanKeyword{var} \spanIdentifier{myVariable}\spanPunctuation{:} \spanIdentifier{int} \spanComment{\#\# a documentation comment}
\end{rstpre}
Los comentarios de documentación son tokens; Solo se permiten en ciertos lugares en el archivo de entrada ya que pertenecen al árbol de sintaxis! Esta característica permite generadores de documentación más simples.

Los comentarios de varias líneas se inician con \texttt{\#\symbol{91}} y terminan con \texttt{\symbol{93}\#}. Los comentarios multilínea también pueden ser anidados.

\begin{rstpre}
\spanLongComment{\#\symbol{91}
  You can have any Nim code text commented
  out inside this with no indentation restrictions.
    yes("May I ask a pointless question?")
  \#\symbol{91}
    Note: these can be nested!!
  \symbol{93}\#
\symbol{93}\#}
\end{rstpre}
\textbf{Números}

Los literales numéricos se escriben como en la mayoría de los otros idiomas. Como un giro especial, se permiten guiones bajos para una mejor legibilidad: \texttt{1\_000\_000\symbol{96}\symbol{96} (un millón). Un número que contiene un punto (o 'e' o 'E') es un literal de punto flotante: \symbol{96}\symbol{96}1.0e9\symbol{96}\symbol{96} (mil millones). Los literales hexadecimales están prefijados con \symbol{96}\symbol{96}0x}, los literales binarios con \symbol{96}\symbol{96}0b\symbol{96}\symbol{96} y los literales octales con \symbol{96}\symbol{96}0o\symbol{96}\symbol{96}. Un cero inicial solo no produce un octal.

\rsthB{La sentencia \textbf{var}}\label{la-sentencia-var}
La declaración \texttt{var} declara una nueva variable local o global:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}  \spanComment{\# declares x and y to have the type \symbol{96}\symbol{96}int\symbol{96}\symbol{96}}
\end{rstpre}
La Indentacion puede ser usada luego de \texttt{var} para agrupar un conjunto de variables:

\begin{rstpre}
\spanKeyword{var}
  \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y} \spanPunctuation{:}\spanIdentifier{int}
  \spanComment{\# a comment}
  \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{,} \spanIdentifier{c} \spanPunctuation{:}\spanIdentifier{string}
\end{rstpre}
\rsthB{La declaración de asignación}\label{la-declaración-de-asignación}
La declaración de asignación asigna un nuevo valor a una variable o, más generalmente, a una ubicación de almacenamiento:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{x} \spanOperator{=} \spanStringLit{"abc"} \spanComment{\# introduces a new variable \symbol{96}x\symbol{96} and assigns a value to it}
\spanIdentifier{x} \spanOperator{=} \spanStringLit{"xyz"}     \spanComment{\# assigns a new value to \symbol{96}x\symbol{96}}
\end{rstpre}
\texttt{=} es el operador de asignación . El operador de asignación puede estar sobrecargado. Puede declarar múltiples variables con una sola instrucción de asignación y todas las variables tendrán el mismo valor:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y} \spanOperator{=} \spanDecNumber{3}  \spanComment{\# assigns 3 to the variables \symbol{96}x\symbol{96} and \symbol{96}y\symbol{96}}
\spanIdentifier{echo} \spanStringLit{"x "}\spanPunctuation{,} \spanIdentifier{x}  \spanComment{\# outputs "x 3"}
\spanIdentifier{echo} \spanStringLit{"y "}\spanPunctuation{,} \spanIdentifier{y}  \spanComment{\# outputs "y 3"}
\spanIdentifier{x} \spanOperator{=} \spanDecNumber{42}        \spanComment{\# changes \symbol{96}x\symbol{96} to 42 without changing \symbol{96}y\symbol{96}}
\spanIdentifier{echo} \spanStringLit{"x "}\spanPunctuation{,} \spanIdentifier{x}  \spanComment{\# outputs "x 42"}
\spanIdentifier{echo} \spanStringLit{"y "}\spanPunctuation{,} \spanIdentifier{y}  \spanComment{\# outputs "y 3"}
\end{rstpre}
Tenga en cuenta que la declaración de múltiples variables con una sola asignación que llama a un procedimiento puede tener resultados inesperados: El compilador desenrollará las asignaciones y terminará llamando al procedimiento varias veces. Si el resultado del procedimiento depende de los efectos secundarios, ¡sus variables pueden terminar teniendo valores diferentes!. Para seguridad, utilice procedimientos libres de efectos secundarios si realiza múltiples tareas.

\rsthB{Constantes}\label{constantes}
Las constantes son símbolos que están vinculados a un valor. El valor de la constante no puede cambiar. El compilador debe poder evaluar la expresión en una declaración constante en tiempo de compilación:

\begin{rstpre}
\spanKeyword{const} \spanIdentifier{x} \spanOperator{=} \spanStringLit{"abc"} \spanComment{\# the constant x contains the string "abc"}
\end{rstpre}
La sangría se puede usar después de la palabra clave const para enumerar una sección completa de constantes:

\begin{rstpre}
\spanKeyword{const}
  \spanIdentifier{x} \spanOperator{=} \spanDecNumber{1}
  \spanComment{\# a comment can occur here too}
  \spanIdentifier{y} \spanOperator{=} \spanDecNumber{2}
  \spanIdentifier{z} \spanOperator{=} \spanIdentifier{y} \spanOperator{+} \spanDecNumber{5} \spanComment{\# computations are possible}
\end{rstpre}
\rsthB{La declaración de \emph{let}}\label{la-declaración-de-let}
La instrucción \texttt{let} funciona igual que la instrucción \texttt{var}, pero los símbolos declarados son variables de asignación única: después de la inicialización, su valor no puede cambiar:

\begin{rstpre}
\spanKeyword{let} \spanIdentifier{x} \spanOperator{=} \spanStringLit{"abc"} \spanComment{\# introduces a new variable \symbol{96}x\symbol{96} and binds a value to it}
\spanIdentifier{x} \spanOperator{=} \spanStringLit{"xyz"}     \spanComment{\# Illegal: assignment to \symbol{96}x\symbol{96}}
\end{rstpre}
La diferencia entre \texttt{let} y \texttt{const} es: Permite introducir una variable que no se puede volver a asignar, \texttt{const} significa "imponer la evaluación del tiempo de compilación y colocarla en una sección de datos":

\begin{rstpre}
\spanKeyword{const} \spanIdentifier{input} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{stdin}\spanPunctuation{)} \spanComment{\# Error: constant expression expected}
\end{rstpre}
\begin{rstpre}
\spanKeyword{let} \spanIdentifier{input} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{stdin}\spanPunctuation{)}   \spanComment{\# works}
\end{rstpre}
\rsthB{Declaraciones de flujo de control}\label{declaraciones-de-flujo-de-control}
El programa de saludos consta de 3 instrucciones que se ejecutan de forma secuencial. Solo los programas más primitivos pueden salirse con la suya: También se necesitan ramificaciones y bucles.

\textbf{if declaración}

La instrucción \texttt{if} es una forma de ramificar el flujo de control:

\begin{rstpre}
\spanKeyword{let} \spanIdentifier{name} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{stdin}\spanPunctuation{)}
\spanKeyword{if} \spanIdentifier{name} \spanOperator{==} \spanStringLit{""}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Poor soul, you lost your name?"}
\spanKeyword{elif} \spanIdentifier{name} \spanOperator{==} \spanStringLit{"name"}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Very funny, your name is name."}
\spanKeyword{else}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Hi, "}\spanPunctuation{,} \spanIdentifier{name}
\end{rstpre}
Puede haber cero o más partes \texttt{elif}, y la \texttt{else} parte es opcional. La palabra clave \texttt{elif} es la abreviatura de \texttt{else} \texttt{if}, y es útil para evitar una sangría excesiva. (La \texttt{""} es la cadena vacía. No contiene caracteres.)

\textbf{case Declaración}

Otra forma de ramificación es proporcionada por la declaración de \texttt{case}. Una declaración de caso es una rama múltiple:

\begin{rstpre}
\spanKeyword{let} \spanIdentifier{name} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{stdin}\spanPunctuation{)}
\spanKeyword{case} \spanIdentifier{name}
\spanKeyword{of} \spanStringLit{""}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Poor soul, you lost your name?"}
\spanKeyword{of} \spanStringLit{"name"}\spanPunctuation{:}
   \spanStringLit{"Very funny, your name is name."}
\spanKeyword{of} \spanStringLit{"Dave"}\spanPunctuation{,} \spanStringLit{"Frank"}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Cool name!"}
\spanKeyword{else}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Hi, "}\spanPunctuation{,} \spanIdentifier{name}
\end{rstpre}
Como se puede ver, para una \texttt{of} rama una coma separó la lista de valores también está permitido.

La declaración de caso puede tratar con enteros, otros tipos ordinales y cadenas. (Lo que un tipo ordinal es se explicará pronto). Para enteros u otros tipos de ordinales también son posibles rangos de valores:

\begin{rstpre}
\spanComment{\# this statement will be explained later:}
\spanKeyword{from} \spanIdentifier{strutils} \spanKeyword{import} \spanIdentifier{parseInt}

\spanIdentifier{echo} \spanStringLit{"A number please: "}
\spanKeyword{let} \spanIdentifier{n} \spanOperator{=} \spanIdentifier{parseInt}\spanPunctuation{(}\spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{stdin}\spanPunctuation{)}\spanPunctuation{)}
\spanKeyword{case} \spanIdentifier{n}
\spanKeyword{of} \spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{2}\spanPunctuation{,} \spanFloatNumber{4.}\spanOperator{.}\spanDecNumber{7}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"The number is in the set: \symbol{123}0, 1, 2, 4, 5, 6, 7\symbol{125}"}
\spanKeyword{of} \spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{8}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"The number is 3 or 8"}
\end{rstpre}
Sin embargo, el código anterior no se compila: Emotivo es que debe cubrir todos los valores que \texttt{n} puede contener, pero el código solo maneja los valores \texttt{0..8}. Dado que no es muy práctico enumerar todos los demás enteros posibles (aunque es posible gracias a la notación de rango), solucionamos esto indicando al compilador que por cada otro valor no se debe hacer nada:

\begin{rstpre}
\spanKeyword{case} \spanIdentifier{n}
\spanKeyword{of} \spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{2}\spanPunctuation{,} \spanFloatNumber{4.}\spanOperator{.}\spanDecNumber{7}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"The number is in the set: \symbol{123}0, 1, 2, 4, 5, 6, 7\symbol{125}"}
\spanKeyword{of} \spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{8}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"The number is 3 or 8"}
\spanKeyword{else}\spanPunctuation{:} \spanKeyword{discard}
\end{rstpre}
La declaración de \texttt{discard} vacía es una declaración de no hacer nada. El compilador sabe que una declaración de caso con una parte else no puede fallar y, por lo tanto, el error desaparece. Tenga en cuenta que es imposible cubrir todos los valores de cadena posibles: Es por eso que los casos de cadena siempre necesitan una rama \texttt{else}.

En general, la declaración de caso se usa para los tipos de subrango o enumeración donde el compilador comprueba que cubrió cualquier valor posible.

\textbf{while declaración}

La instrucción while es una construcción de bucle simple:

\begin{rstpre}
\spanIdentifier{echo} \spanStringLit{"What's your name? "}
\spanKeyword{var} \spanIdentifier{name} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{stdin}\spanPunctuation{)}
\spanKeyword{while} \spanIdentifier{name} \spanOperator{==} \spanStringLit{""}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Please tell me your name: "}
  \spanIdentifier{name} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{stdin}\spanPunctuation{)}
  \spanComment{\# no \symbol{96}\symbol{96}var\symbol{96}\symbol{96}, because we do not declare a new variable here}
\end{rstpre}
El ejemplo utiliza un bucle while para seguir preguntando a los usuarios por su nombre, siempre y cuando el usuario no escriba nada (solo presione RETORNO).

\textbf{for declaración}

La instrucción \texttt{for} es una construcción para recorrer cualquier elemento que proporciona un iterador. El ejemplo utiliza el iterador incorporado de cuenta atrás:

\begin{rstpre}
\spanIdentifier{echo} \spanStringLit{"Counting to ten: "}
\spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanIdentifier{countup}\spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{10}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{i}
\spanComment{\# --> Outputs 1 2 3 4 5 6 7 8 9 10 on different lines}
\end{rstpre}
La variable \texttt{i} es declarada implícitamente por el bucle \texttt{for} y tiene el tipo \texttt{int}, porque eso es lo que devuelve el conteo. \texttt{i} corre a través de los valores 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. Cada valor es mostrado con \texttt{echo}. Este código hace lo mismo:

\begin{rstpre}
\spanIdentifier{echo} \spanStringLit{"Counting to 10: "}
\spanKeyword{var} \spanIdentifier{i} \spanOperator{=} \spanDecNumber{1}
\spanKeyword{while} \spanIdentifier{i} \spanOperator{<=} \spanDecNumber{10}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{i}
  \spanIdentifier{inc} \spanIdentifier{i}  \spanComment{\# increment i by 1}
\spanComment{\# --> Outputs 1 2 3 4 5 6 7 8 9 10 on different lines}
\end{rstpre}
La cuenta regresiva se puede lograr con la misma facilidad (pero es menos necesaria):

\begin{rstpre}
\spanIdentifier{echo} \spanStringLit{"Counting down from 10 to 1: "}
\spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanIdentifier{countdown}\spanPunctuation{(}\spanDecNumber{10}\spanPunctuation{,} \spanDecNumber{1}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{i}
\spanComment{\# --> Outputs 10 9 8 7 6 5 4 3 2 1 on different lines}
\end{rstpre}
Desde contando ocurre tan a menudo en los programas, Nim también tiene un \texttt{..} iterador que hace lo mismo:

\begin{rstpre}
\spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{1.}\spanOperator{.}\spanDecNumber{10}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{i}
\end{rstpre}
El conteo de índice cero tiene dos accesos directos \texttt{..<} y \texttt{..\symbol{94}} para simplificar el conteo a uno menos que el índice más alto:

\begin{rstpre}
\spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.<}\spanDecNumber{10}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{i}  \spanComment{\# 0..9}
\end{rstpre}
o

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{s} \spanOperator{=} \spanStringLit{"some string"}
\spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.<}\spanIdentifier{s}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{i}
\end{rstpre}
Otros iteradores útiles para colecciones (como matrices y secuencias) son:

\begin{itemize}\item \texttt{items} y \texttt{mitems}, que proporciona elementos inmutables y mutables respectivamente.
\item \texttt{pairs} y \texttt{mpairs} que proporcionan el elemento y un número de índice (inmutable y mutable respectivamente)
\end{itemize}
\begin{rstpre}
\spanKeyword{for} \spanIdentifier{index}\spanPunctuation{,} \spanIdentifier{item} \spanKeyword{in} \spanPunctuation{\symbol{91}}\spanStringLit{"a"}\spanPunctuation{,} \spanStringLit{"b"}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanIdentifier{pairs}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{item}\spanPunctuation{,} \spanStringLit{" at index "}\spanPunctuation{,} \spanIdentifier{index}
  \spanComment{\# => a at index 0}
  \spanComment{\# => b at index 1}
\end{rstpre}
\textbf{Los ámbitos y la declaración de block}

Las declaraciones de flujo de control tienen una característica aún no cubierta: Abren un nuevo ámbito (contexto). Esto significa que en el siguiente ejemplo, \texttt{x} no es accesible fuera del bucle:

\begin{rstpre}
\spanKeyword{while} \spanIdentifier{false}\spanPunctuation{:}
  \spanKeyword{var} \spanIdentifier{x} \spanOperator{=} \spanStringLit{"hi"}
\spanIdentifier{echo} \spanIdentifier{x}  \spanComment{\# does not work}
\end{rstpre}
Una sentencia while (para) introduce un bloque implícito. Los identificadores solo son visibles dentro del bloque que han sido declarados. La instrucción de \texttt{block} se puede usar para abrir un nuevo bloque explícitamente:

\begin{rstpre}
\spanKeyword{block} \spanIdentifier{myblock}\spanPunctuation{:}
  \spanKeyword{var} \spanIdentifier{x} \spanOperator{=} \spanStringLit{"hi"}
\spanIdentifier{echo} \spanIdentifier{x} \spanComment{\# does not work either}
\end{rstpre}
La etiqueta del bloque (\texttt{myblock} en el ejemplo) es opcional.

\textbf{break Declaración}

Un bloque se puede dejar prematuramente con una instrucción break . La instrucción \texttt{break} puede dejar un \texttt{while} , \symbol{96}\symbol{96} for\symbol{96}\symbol{96}, o una instrucción de \texttt{block} . Abandona la construcción más interna, a menos que se dé una etiqueta de un bloque:

\begin{rstpre}
\spanKeyword{block} \spanIdentifier{myblock}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"entering block"}
  \spanKeyword{while} \spanIdentifier{true}\spanPunctuation{:}
    \spanIdentifier{echo} \spanStringLit{"looping"}
    \spanKeyword{break} \spanComment{\# leaves the loop, but not the block}
  \spanIdentifier{echo} \spanStringLit{"still in block"}

\spanKeyword{block} \spanIdentifier{myblock2}\spanPunctuation{:}
\spanIdentifier{echo} \spanStringLit{"entering block"}
\spanKeyword{while} \spanIdentifier{true}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"looping"}
  \spanKeyword{break} \spanIdentifier{myblock2} \spanComment{\# leaves the block (and the loop)}
\spanIdentifier{echo} \spanStringLit{"still in block"}
\end{rstpre}
\textbf{continue declaración}

Al igual que en muchos otros lenguajes de programación, una instrucción de \texttt{continue} comienza la siguiente iteración inmediatamente:

\begin{rstpre}
\spanKeyword{while} \spanIdentifier{true}\spanPunctuation{:}
  \spanKeyword{let} \spanIdentifier{x} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{stdin}\spanPunctuation{)}
  \spanKeyword{if} \spanIdentifier{x} \spanOperator{==} \spanStringLit{""}\spanPunctuation{:} \spanKeyword{continue}
  \spanIdentifier{echo} \spanIdentifier{x}
\end{rstpre}
\textbf{when declaración}

Ejemplo:

\begin{rstpre}
\spanKeyword{when} \spanIdentifier{hostOS} \spanOperator{==} \spanStringLit{"windows"}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"running on Windows!"}
\spanKeyword{elif} \spanIdentifier{hostOS} \spanOperator{==} \spanStringLit{"linux"}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"running on Linux!"}
\spanKeyword{elif} \spanIdentifier{hostOS} \spanOperator{==} \spanStringLit{"macosx"}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"running on Mac OS X!"}
\spanKeyword{else}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"unknown operating system"}
\end{rstpre}
La instrucción \texttt{when} es casi idéntica a la instrucción \texttt{if}, pero con estas diferencias:

\begin{itemize}\item Cada condición debe ser una expresión constante ya que es evaluada por el compilador.
\item Las declaraciones dentro de una rama no abren un nuevo alcance.
\item El compilador comprueba la semántica y produce código solo para las
\end{itemize}
declaraciones que pertenecen a la primera condición que se evalúa como \texttt{true}.

La instrucción \texttt{when} es útil para escribir código específico de plataforma, similar a la construcción \texttt{\#ifdef} en el lenguaje de programación C.

\rsthB{Declaraciones y sangría}\label{declaraciones-y-sangría}
Ahora que cubrimos las declaraciones de flujo de control básico, volvamos a las reglas de sangría de Nim.

En Nim hay una distinción entre declaraciones simples y declaraciones complejas . Las declaraciones simples no pueden contener otras declaraciones: La asignación, las llamadas a procedimientos o la declaración de devolución pertenecen a las declaraciones simples.

Las declaraciones complejas como \texttt{if}, \texttt{when} , \texttt{for} , \texttt{while} pueden contener otras declaraciones. Para evitar ambiguedades, las declaraciones complejas siempre deben estar sangradas, pero las declaraciones simples y simples no:

\begin{rstpre}
\spanComment{\# no indentation needed for single assignment statement:}
\spanKeyword{if} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{x} \spanOperator{=} \spanIdentifier{false}

\spanComment{\# indentation needed for nested if statement:}
\spanKeyword{if} \spanIdentifier{x}\spanPunctuation{:}
  \spanKeyword{if} \spanIdentifier{y}\spanPunctuation{:}
    \spanIdentifier{y} \spanOperator{=} \spanIdentifier{false}
\spanKeyword{else}\spanPunctuation{:}
  \spanIdentifier{y} \spanOperator{=} \spanIdentifier{true}

\spanComment{\# indentation needed, because two statements follow the condition:}
\spanKeyword{if} \spanIdentifier{x}\spanPunctuation{:}
  \spanIdentifier{x} \spanOperator{=} \spanIdentifier{false}
  \spanIdentifier{y} \spanOperator{=} \spanIdentifier{false}
\end{rstpre}
Las expresiones son parte de una declaración que generalmente resulta en un valor. La condición en una sentencia if es un ejemplo para una expresión. Las expresiones pueden contener sangría en ciertos lugares para una mejor legibilidad:

\begin{rstpre}
\spanKeyword{if} \spanIdentifier{thisIsaLongCondition}\spanPunctuation{(}\spanPunctuation{)} \spanKeyword{and}
  \spanIdentifier{thisIsAnotherLongCondition}\spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{,}
      \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{x} \spanOperator{=} \spanIdentifier{true}
\end{rstpre}
Como regla general, se permite la sangría dentro de las expresiones después de los operadores, un paréntesis abierto y después de las comas.

Con paréntesis y punto y coma \texttt{( ; )} puede usar sentencias donde solo se permite una expresión:

\begin{rstpre}
\spanComment{\# computes fac(4) at compile time:}
\spanKeyword{const} \spanIdentifier{fac4} \spanOperator{=} \spanPunctuation{(}\spanKeyword{var} \spanIdentifier{x} \spanOperator{=} \spanDecNumber{1} \spanPunctuation{;} \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{1.}\spanOperator{.}\spanDecNumber{4}\spanPunctuation{:} \spanIdentifier{x} \spanOperator{*=} \spanIdentifier{i} \spanPunctuation{;} \spanIdentifier{x}\spanPunctuation{)}
\end{rstpre}
\rsthB{Procedimientos}\label{procedimientos}
Para definir nuevos comandos como echo y readLine en los ejemplos, se necesita el concepto de un \texttt{procedimiento}. (Algunos idiomas los llaman métodos o funciones ). En Nim, los nuevos procedimientos se definen con la palabra clave \texttt{proc}:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{yes}\spanPunctuation{(}\spanIdentifier{question}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=}
  \spanIdentifier{echo} \spanIdentifier{question}\spanPunctuation{,} \spanStringLit{" (y/n)"}
  \spanKeyword{while} \spanIdentifier{true}\spanPunctuation{:}
    \spanKeyword{case} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{stdin}\spanPunctuation{)}
    \spanKeyword{of} \spanStringLit{"y"}\spanPunctuation{,} \spanStringLit{"Y"}\spanPunctuation{,} \spanStringLit{"yes"}\spanPunctuation{,} \spanStringLit{"Yes"}\spanPunctuation{:} \spanKeyword{return} \spanIdentifier{true}
    \spanKeyword{of} \spanStringLit{"n"}\spanPunctuation{,} \spanStringLit{"N"}\spanPunctuation{,} \spanStringLit{"no"}\spanPunctuation{,} \spanStringLit{"No"}\spanPunctuation{:} \spanKeyword{return} \spanIdentifier{false}
    \spanKeyword{else}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"Please be clear: yes or no"}

\spanKeyword{if} \spanIdentifier{yes}\spanPunctuation{(}\spanStringLit{"Should I delete all your important files?"}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"I'm sorry Dave, I'm afraid I can't do that."}
\spanKeyword{else}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"I think you know what the problem is just as well as I do."}
\end{rstpre}
Este ejemplo muestra un procedimiento llamado sí que hace una pregunta al usuario y devuelve verdadero si contestó "sí" (o algo similar) y devuelve falso si respondió "no" (o algo similar). Una declaración de retorno abandona el procedimiento (y, por lo tanto, el bucle while) inmediatamente. La ( sintaxis : cadena): \texttt{bool} describe que el procedimiento espera un parámetro llamado pregunta de tipo \texttt{cadena} y devuelve un valor de tipo \texttt{bool} . El tipo bool está integrado: los únicos valores válidos para \texttt{bool} son \texttt{true} y \texttt{false}. Las condiciones en las sentencias if o while deben ser de tipo \texttt{bool}.

Alguna terminología: En la pregunta de ejemplo se llama un parámetro (formal), "Debería ..." se llama un argumento que se pasa a este parámetro.

\textbf{Variable de resultado}

Un procedimiento que devuelve un valor tiene una variable de \texttt{result} implícita declarada que representa el valor de retorno. Una declaración de \texttt{return} sin expresión es una abreviatura para el \texttt{return result}. El valor del \texttt{result} siempre se devuelve automáticamente al final de un procedimiento si no hay una declaración de \texttt{return} en la salida.

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{sumTillNegative}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{varargs}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanIdentifier{x}\spanPunctuation{:}
    \spanKeyword{if} \spanIdentifier{i} \spanOperator{<} \spanDecNumber{0}\spanPunctuation{:}
      \spanKeyword{return}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{result} \spanOperator{+} \spanIdentifier{i}

\spanIdentifier{echo} \spanIdentifier{sumTillNegative}\spanPunctuation{(}\spanPunctuation{)} \spanComment{\# echos 0}
\spanIdentifier{echo} \spanIdentifier{sumTillNegative}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{,} \spanDecNumber{5}\spanPunctuation{)} \spanComment{\# echos 12}
\spanIdentifier{echo} \spanIdentifier{sumTillNegative}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4} \spanPunctuation{,} \spanOperator{-}\spanDecNumber{1} \spanPunctuation{,} \spanDecNumber{6}\spanPunctuation{)} \spanComment{\# echos 7}
\end{rstpre}
La variable de \texttt{result} ya está declarada implícitamente al inicio de la función, por lo que declararla de nuevo con \texttt{var result}, por ejemplo, la sombrearía con una variable normal del mismo nombre. La variable de resultado también ya está inicializada con el valor predeterminado del tipo. Tenga en cuenta que los tipos de datos referenciales serán \texttt{nil} al inicio del procedimiento y, por lo tanto, pueden requerir una inicialización manual.

\textbf{Parámetros}

Los parámetros son inmutables en el cuerpo del procedimiento. De forma predeterminada, su valor no se puede cambiar porque esto permite al compilador implementar el paso de parámetros de la manera más eficiente. Si se necesita una variable mutable dentro del procedimiento, debe declararse con \texttt{var} en el cuerpo del procedimiento. Es posible sombrear el nombre del parámetro, y en realidad un idioma:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{printSeq}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{,} \spanIdentifier{nprinted}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanOperator{-}\spanDecNumber{1}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{nprinted} \spanOperator{=} \spanKeyword{if} \spanIdentifier{nprinted} \spanOperator{==} \spanOperator{-}\spanDecNumber{1}\spanPunctuation{:} \spanIdentifier{s}\spanOperator{.}\spanIdentifier{len} \spanKeyword{else}\spanPunctuation{:} \spanIdentifier{min}\spanPunctuation{(}\spanIdentifier{nprinted}\spanPunctuation{,} \spanIdentifier{s}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{)}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanDecNumber{0} \spanOperator{..} \spanOperator{<}\spanIdentifier{nprinted}\spanPunctuation{:}
    \spanIdentifier{echo} \spanIdentifier{s}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}
\end{rstpre}
Si el procedimiento necesita modificar el argumento para la persona que llama, se puede usar un parámetro \texttt{var}:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{divmod}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{;} \spanIdentifier{res}\spanPunctuation{,} \spanIdentifier{remainder}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{res} \spanOperator{=} \spanIdentifier{a} \spanKeyword{div} \spanIdentifier{b}        \spanComment{\# integer division}
  \spanIdentifier{remainder} \spanOperator{=} \spanIdentifier{a} \spanKeyword{mod} \spanIdentifier{b}  \spanComment{\# integer modulo operation}

\spanKeyword{var} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}
\spanIdentifier{divmod}\spanPunctuation{(}\spanDecNumber{8}\spanPunctuation{,} \spanDecNumber{5}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{)} \spanComment{\# modifies x and y}
\spanIdentifier{echo} \spanIdentifier{x}
\spanIdentifier{echo} \spanIdentifier{y}
\end{rstpre}
En el ejemplo, \texttt{res} y \texttt{remainder} son \texttt{var parameters}. Los parámetros de la var pueden ser modificados por el procedimiento y los cambios son visibles para la persona que llama. Tenga en cuenta que el ejemplo anterior sería mejor utilizar una tupla como valor de retorno en lugar de usar los parámetros var.

\textbf{Declaración de descarte}

Para llamar a un procedimiento que devuelve un valor solo por sus efectos secundarios e ignorando su valor de retorno, se debe usar una declaración de \texttt{discard}. Nim no permite tirar silenciosamente un valor de retorno:

\begin{rstpre}
\spanKeyword{discard} \spanIdentifier{yes}\spanPunctuation{(}\spanStringLit{"May I ask a pointless question?"}\spanPunctuation{)}
\end{rstpre}
El valor de retorno se puede ignorar implícitamente si el \texttt{proc} / \texttt{iterator} llamado se ha declarado con el pragma \texttt{discardable}:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{discardable}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanKeyword{return} \spanIdentifier{x} \spanOperator{+} \spanIdentifier{y}

\spanIdentifier{p}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{)} \spanComment{\# now valid}
\end{rstpre}
\textbf{Argumentos con nombre}

A menudo, un procedimiento tiene muchos parámetros y no está claro en qué orden aparecen los parámetros. Esto es especialmente cierto para los procedimientos que construyen un tipo de datos complejo. Por lo tanto, los argumentos de un procedimiento se pueden nombrar, de modo que quede claro qué argumento pertenece a qué parámetro:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{createWindow}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{,} \spanIdentifier{width}\spanPunctuation{,} \spanIdentifier{height}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{;} \spanIdentifier{title}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{;}
                  \spanIdentifier{show}\spanPunctuation{:} \spanIdentifier{bool}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Window} \spanOperator{=}
  \spanOperator{...}

\spanKeyword{var} \spanIdentifier{w} \spanOperator{=} \spanIdentifier{createWindow}\spanPunctuation{(}\spanIdentifier{show} \spanOperator{=} \spanIdentifier{true}\spanPunctuation{,} \spanIdentifier{title} \spanOperator{=} \spanStringLit{"My Application"}\spanPunctuation{,}
                     \spanIdentifier{x} \spanOperator{=} \spanDecNumber{0}\spanPunctuation{,} \spanIdentifier{y} \spanOperator{=} \spanDecNumber{0}\spanPunctuation{,} \spanIdentifier{height} \spanOperator{=} \spanDecNumber{600}\spanPunctuation{,} \spanIdentifier{width} \spanOperator{=} \spanDecNumber{800}\spanPunctuation{)}
\end{rstpre}
Ahora que usamos argumentos con nombre para llamar a \texttt{createWindow}, el orden de los argumentos ya no importa. También es posible mezclar argumentos nombrados con argumentos ordenados, pero no es muy legible:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{w} \spanOperator{=} \spanIdentifier{createWindow}\spanPunctuation{(}\spanDecNumber{0}\spanPunctuation{,} \spanDecNumber{0}\spanPunctuation{,} \spanIdentifier{title} \spanOperator{=} \spanStringLit{"My Application"}\spanPunctuation{,}
                     \spanIdentifier{height} \spanOperator{=} \spanDecNumber{600}\spanPunctuation{,} \spanIdentifier{width} \spanOperator{=} \spanDecNumber{800}\spanPunctuation{,} \spanIdentifier{true}\spanPunctuation{)}
\end{rstpre}
El compilador comprueba que cada parámetro recibe exactamente un argumento.

\textbf{Valores predeterminados}

Para que el proceso \texttt{createWindow} sea ​​más fácil de usar, debe proporcionar \texttt{default values} ; Estos son valores que se utilizan como argumentos si el llamante no los especifica:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{createWindow}\spanPunctuation{(}\spanIdentifier{x} \spanOperator{=} \spanDecNumber{0}\spanPunctuation{,} \spanIdentifier{y} \spanOperator{=} \spanDecNumber{0}\spanPunctuation{,} \spanIdentifier{width} \spanOperator{=} \spanDecNumber{500}\spanPunctuation{,} \spanIdentifier{height} \spanOperator{=} \spanDecNumber{700}\spanPunctuation{,}
                  \spanIdentifier{title} \spanOperator{=} \spanStringLit{"unknown"}\spanPunctuation{,}
                  \spanIdentifier{show} \spanOperator{=} \spanIdentifier{true}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Window} \spanOperator{=}
  \spanOperator{...}

\spanKeyword{var} \spanIdentifier{w} \spanOperator{=} \spanIdentifier{createWindow}\spanPunctuation{(}\spanIdentifier{title} \spanOperator{=} \spanStringLit{"My Application"}\spanPunctuation{,} \spanIdentifier{height} \spanOperator{=} \spanDecNumber{600}\spanPunctuation{,} \spanIdentifier{width} \spanOperator{=} \spanDecNumber{800}\spanPunctuation{)}
\end{rstpre}
Ahora la llamada a \texttt{createWindow} solo necesita establecer los valores que difieren de los valores predeterminados.

Tenga en cuenta que la inferencia de tipos funciona para parámetros con valores predeterminados; No hay necesidad de escribir \texttt{title: string = "unknown"}, por ejemplo.

\textbf{Procedimientos sobrecargados}

Nim proporciona la capacidad de sobrecargar procedimientos similares a C++

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{toString}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{)}\spanPunctuation{:}  \spanIdentifier{string}  \spanOperator{=}  \spanOperator{...}
\spanKeyword{proc} \spanIdentifier{toString}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{bool} \spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string}  \spanOperator{=}
  \spanKeyword{if} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{result} \spanOperator{=} \spanStringLit{"true"}
  \spanKeyword{else}\spanPunctuation{:} \spanIdentifier{result} \spanOperator{=} \spanStringLit{"false"}

\spanIdentifier{echo} \spanIdentifier{toString}\spanPunctuation{(}\spanDecNumber{13}\spanPunctuation{)}   \spanComment{\# llama al toString (x: int) proc}
\spanIdentifier{echo} \spanIdentifier{toString}\spanPunctuation{(}\spanIdentifier{true}\spanPunctuation{)} \spanComment{\# llama al proceso toString (x: bool) proc}
\end{rstpre}
(Tenga en cuenta que \texttt{toString} suele ser el operador \$ en Nim). El compilador elige el proceso más apropiado para las llamadas a \texttt{toString} . Aquí no se explica cómo funciona exactamente este algoritmo de resolución de sobrecarga (se especificará en el manual en breve). Sin embargo, no conduce a sorpresas desagradables y se basa en un algoritmo de unificación bastante simple. Las llamadas ambiguas se reportan como errores.

Los operadores

La biblioteca Nim hace un uso intensivo de la sobrecarga, una de las razones es que cada operador como + es solo un proceso sobrecargado. El analizador le permite usar operadores en \texttt{infix notation (a + b)} o \texttt{prefix notation (+ a)}. Un operador de infijo siempre recibe dos argumentos, un operador de prefijo siempre uno. (Los operadores de Postfix no son posibles, porque esto sería ambiguo: \texttt{a \symbol{64} \symbol{64} b significa (a) \symbol{64} (\symbol{64}b)} o \texttt{( a \symbol{64} ) \symbol{64} (b)} ? Siempre significa \texttt{(a) \symbol{64} (\symbol{64}b)} , porque no hay operadores de postfix en Nim.)

Aparte de unos cuantos incorporado operadores de palabras clave tales como \texttt{and}, \texttt{or}, \texttt{not}, los operadores siempre constan de los siguientes caracteres: \texttt{+ - * \symbol{92} / <> = \symbol{64} \$ \symbol{126} \&\%! ? \symbol{94}. |}

Se permiten operadores definidos por el usuario. Nada le impide definir su propio operador \texttt{\symbol{64}!? + \symbol{126}}, Pero hacerlo puede reducir la legibilidad.

La precedencia del operador está determinada por su primer carácter. Los detalles se pueden encontrar en el manual.

Para definir un nuevo operador, encierre el operador en backticks:

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{\$}\spanPunctuation{\symbol{96}} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{myDataType}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanOperator{...}
  \spanComment{\# now the \$ operator also works with myDataType, overloading resolution}
  \spanComment{\# ensures that \$ works for built-in types just like before}
\end{rstpre}
La notación backticks también se puede usar para llamar a un operador como cualquier otro procedimiento:

\begin{rstpre}
\spanKeyword{if} \spanPunctuation{\symbol{96}}\spanOperator{==}\spanPunctuation{\symbol{96}}\spanPunctuation{(} \spanPunctuation{\symbol{96}}\spanOperator{+}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{)}\spanPunctuation{,} \spanDecNumber{7}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"true"}
\end{rstpre}
\textbf{Forward Declarations}

Cada variable, procedimiento, etc. debe ser declarado antes de que pueda ser utilizado. (La razón de esto es que no es trivial evitar esta necesidad en un lenguaje que

\begin{description}\item[admita la programación meta tan ampliamente como lo hace Nim).] Sin embargo, esto no se puede hacer para procedimientos recursivos mutuos:
\end{description}
\begin{rstpre}
\spanComment{\# forward declaration:}
\spanKeyword{proc} \spanIdentifier{even}\spanPunctuation{(}\spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool}
\spanKeyword{proc} \spanIdentifier{odd}\spanPunctuation{(}\spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool}
\end{rstpre}
\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{odd}\spanPunctuation{(}\spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=}
  \spanIdentifier{assert}\spanPunctuation{(}\spanIdentifier{n} \spanOperator{>=} \spanDecNumber{0}\spanPunctuation{)} \spanComment{\# makes sure we don't run into negative recursion}
  \spanKeyword{if} \spanIdentifier{n} \spanOperator{==} \spanDecNumber{0}\spanPunctuation{:} \spanIdentifier{false}
  \spanKeyword{else}\spanPunctuation{:}
    \spanIdentifier{n} \spanOperator{==} \spanDecNumber{1} \spanKeyword{or} \spanIdentifier{even}\spanPunctuation{(}\spanIdentifier{n}\spanOperator{-}\spanDecNumber{1}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{even}\spanPunctuation{(}\spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=}
  \spanIdentifier{assert}\spanPunctuation{(}\spanIdentifier{n} \spanOperator{>=} \spanDecNumber{0}\spanPunctuation{)} \spanComment{\# makes sure we don't run into negative recursion}
  \spanKeyword{if} \spanIdentifier{n} \spanOperator{==} \spanDecNumber{1}\spanPunctuation{:} \spanIdentifier{false}
  \spanKeyword{else}\spanPunctuation{:}
    \spanIdentifier{n} \spanOperator{==} \spanDecNumber{0} \spanKeyword{or} \spanIdentifier{odd}\spanPunctuation{(}\spanIdentifier{n}\spanOperator{-}\spanDecNumber{1}\spanPunctuation{)}
\end{rstpre}
Aquí lo \texttt{odd} depende de \texttt{even} y viceversa. Por lo tanto, \texttt{even} es necesario introducirlo en el compilador antes de que esté completamente definido. La sintaxis para tal declaración de reenvío es simple: Simplemente omita el \texttt{=} y el cuerpo del procedimiento. El \texttt{assert} solo agrega condiciones de borde y se cubrirá más adelante en la sección Módulos .

Las versiones posteriores del lenguaje debilitarán los requisitos para las declaraciones a plazo.

El ejemplo también muestra que el cuerpo de un proceso puede consistir en una sola expresión cuyo valor se devuelve implícitamente.

\rsthB{Iteradores}\label{iteradores}
Volvamos al ejemplo de conteo simple:

\begin{rstpre}
\spanIdentifier{echo} \spanStringLit{"Counting to ten: "}
\spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanIdentifier{countup}\spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{10}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{i}
\end{rstpre}
Se puede escribir un proceso de conteo que admita este bucle? Intentemos:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{countup}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{res} \spanOperator{=} \spanIdentifier{a}
  \spanKeyword{while} \spanIdentifier{res} \spanOperator{<=} \spanIdentifier{b}\spanPunctuation{:}
    \spanKeyword{return} \spanIdentifier{res}
    \spanIdentifier{inc} \spanIdentifier{res}
\end{rstpre}
Sin embargo, esto no funciona. El problema es que el procedimiento no solo debe regresar, sino que debe regresar y continuar después de que una iteración haya finalizado. Este retorno y continuar se llama una declaración de rendimiento. Ahora lo único que queda por hacer es reemplazar la palabra clave proc por iterador y aquí está:

Nuestro primer iterador:

\begin{rstpre}
\spanKeyword{iterator} \spanIdentifier{countup}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{res} \spanOperator{=} \spanIdentifier{a}
  \spanKeyword{while} \spanIdentifier{res} \spanOperator{<=} \spanIdentifier{b}\spanPunctuation{:}
    \spanKeyword{yield} \spanIdentifier{res}
    \spanIdentifier{inc} \spanIdentifier{res}
\end{rstpre}
Los iteradores son muy similares a los procedimientos, pero hay varias diferencias importantes:

\begin{itemize}\item Los iteradores solo pueden ser llamados desde los bucles.
\item Los iteradores no pueden contener una declaración de \texttt{return} (y procs no pueden contener una declaración de \texttt{yield} ).
\item Los iteradores no tienen una variable de \texttt{result} implícita .
\item Los iteradores no son compatibles con la recursión.
\item Los iteradores no se pueden declarar hacia delante, porque el compilador debe poder alinear un iterador.
\end{itemize}
(Esta restricción desaparecerá en una versión futura del compilador).

Sin embargo, también puede usar un iterador de \texttt{closure} para obtener un conjunto diferente de restricciones. Ver iteradores de primera clase para más detalles. Los iteradores pueden tener el mismo nombre y parámetros que un proc, ya que esencialmente tienen sus propios espacios de nombres. Por lo tanto, es una práctica común ajustar los iteradores en procesos del mismo nombre que acumulan el resultado del iterador y lo devuelven como una secuencia, como \texttt{split} del módulo strutils .

\rsthB{Tipos basicos}\label{tipos-basicos}
Esta sección trata los tipos básicos integrados y las operaciones que están disponibles para ellos en detalle.

\rsthB{Bool}\label{bool}
El tipo booleano de Nim se llama \texttt{bool} y consiste en los dos valores predefinidos \texttt{true} y \texttt{false} . Las condiciones en \texttt{while}, \texttt{if}, \texttt{elif} y \texttt{when} deben ser de tipo \texttt{bool}.

Los operadores \texttt{not, and, or, xor, <, <=,>,> =,! =, ==} están definidos para el tipo \texttt{bool}. El \texttt{and} y \texttt{or} los operadores de realizar la evaluación de cortocircuito. Por ejemplo:

\begin{rstpre}
\spanKeyword{while} \spanIdentifier{p} \spanOperator{!=} \spanKeyword{nil} \spanKeyword{and} \spanIdentifier{p}\spanOperator{.}\spanIdentifier{name} \spanOperator{!=} \spanStringLit{"xyz"}\spanPunctuation{:}
  \spanComment{\# p.name is not evaluated if p == nil}
  \spanIdentifier{p} \spanOperator{=} \spanIdentifier{p}\spanOperator{.}\spanIdentifier{next}
\end{rstpre}
\rsthB{Char}\label{char}
El tipo caracter es llamado \texttt{char}. Su tamanio es siempre 1 byte, no puede representar caracteres UTF-8; Pero puede representar uno de los bytes que conforman un caracter multi-byte UTF-8. La razon es eficiencia: Para la mayoria de casos de uso mas comunes, los programas resultantes manejan UTF-8 adecuadamente por que UTF-8 fue especificamente disaniado para esto. El literal de un \texttt{char} es encerrado en comilla simple comun.

Los caracteres pueden sen comparados con \texttt{==}, \texttt{<}, \texttt{<=}, \texttt{>}, \texttt{>=}. El operador \texttt{\$} convertira un \texttt{char} a \texttt{string}. Caracteres  no se pueden mezclar con enteros; Para obtener el valor ordinal de un \texttt{char} usar el proc \texttt{ord}. Convertir desde entero a \texttt{char} se hace con el proc \texttt{chr}.

\rsthB{String}\label{string}
Las variables de cadena son \textbf{mutables}, por lo que es posible agregarlas a una cadena, y es bastante eficiente. Las cadenas en Nim son Cero-terminadas (null terminator) y tienen un campo de longitud la longitud de una cadena se puede recuperar con el proc \texttt{len} incorporado; la longitud nunca cuenta el cero final (terminator). Acceder a la terminación cero es un error, solo existe para que una cadena Nim pueda convertirse a un \texttt{cstring} sin hacer una copia.

El operador de asignación para cadenas copia la cadena. Puedes usar el \texttt{\&} operador para concatenar cadenas y \texttt{add} para agregar a una cadena.

Las cadenas se comparan utilizando su orden lexicográfico. Todos los operadores de comparación son compatibles. Por convención, todas las cadenas están codificadas en UTF-8. Por ejemplo, al leer cadenas de archivos binarios, son simplemente una secuencia de bytes. La operación de índice \texttt{s\symbol{91}i\symbol{93}} significa el i-th \texttt{char} de \texttt{s}, no el i-th \texttt{unichar}.

Una variable de cadena se inicializa con la cadena vacía \texttt{""}.

\rsthB{Integers}\label{integers}
Nim tiene estos tipos de enteros incorporados: \texttt{int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64}.

El tipo de entero predeterminado es \texttt{int}. Los literales enteros pueden tener un \emph{sufijo de tipo} para especificar un tipo de entero no predeterminado:

\begin{rstpre}
\spanKeyword{let}
  \spanIdentifier{x} \spanOperator{=} \spanDecNumber{0}     \spanComment{\# x is of type \symbol{96}\symbol{96}int\symbol{96}\symbol{96}}
  \spanIdentifier{y} \spanOperator{=} \spanDecNumber{0'i8}  \spanComment{\# y is of type \symbol{96}\symbol{96}int8\symbol{96}\symbol{96}}
  \spanIdentifier{z} \spanOperator{=} \spanDecNumber{0'i64} \spanComment{\# z is of type \symbol{96}\symbol{96}int64\symbol{96}\symbol{96}}
  \spanIdentifier{u} \spanOperator{=} \spanDecNumber{0'}\spanIdentifier{u}   \spanComment{\# u is of type \symbol{96}\symbol{96}uint\symbol{96}\symbol{96}}
\end{rstpre}
La mayoría de los enteros se utilizan para contar objetos que residen en la memoria, por lo que \texttt{int} tiene el mismo tamaño que un puntero.

Los operadores comunes \texttt{+ - * div mod <<= ==! =>> =} se definen para enteros Los operadores \texttt{and / or xor not} también se definen para enteros, y proporcionan operaciones \emph{bitwise}. El desplazamiento de bits a la izquierda se realiza con el \texttt{shl}, a la derecha cambiando con el operador \texttt{shr}. Los operadores de cambio de bits siempre tratan sus argumentos como \emph{sin firmar} (Unsigned).

Las operaciones Unsigned son todas del tipo wrap around; No pueden resultar en errores de overflow o underflow.

\rsthB{Floats}\label{floats}
Nim tiene estos tipos de punto flotante incorporados: \texttt{float float32 float64}.

El tipo float predeterminado es \texttt{float}. En la implementación actual, \texttt{float} es siempre de 64 Bits.

Los literales flotantes pueden tener un \emph{sufijo de tipo} para especificar un tipo de float no predeterminado:

\begin{rstpre}
\spanKeyword{var}
  \spanIdentifier{x} \spanOperator{=} \spanFloatNumber{0.0}      \spanComment{\# x is of type \symbol{96}\symbol{96}float\symbol{96}\symbol{96}}
  \spanIdentifier{y} \spanOperator{=} \spanFloatNumber{0.0'f32}  \spanComment{\# y is of type \symbol{96}\symbol{96}float32\symbol{96}\symbol{96}}
  \spanIdentifier{z} \spanOperator{=} \spanFloatNumber{0.0'f64}  \spanComment{\# z is of type \symbol{96}\symbol{96}float64\symbol{96}\symbol{96}}
\end{rstpre}
Los operadores comunes \texttt{+ - * / < <= == != > >=} estan definidos para float y siguen los Standards de IEEE-754.

La conversión automática de tipos en expresiones con diferentes tipos de flotación: El tipo más pequeño se convierte en el tipo más grande.

Los tipos Enteros \textbf{no} se convierten a tipos de punto flotante automáticamente, ni viceversa.

\rsthB{Type Conversion}\label{type-conversion}
La conversión entre tipos numéricos se realiza utilizando el tipo como una función:

\begin{rstpre}
\spanKeyword{var}
  \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int32} \spanOperator{=} \spanFloatNumber{1.}\spanIdentifier{int32}     \spanComment{\# same as calling int32(1)}
  \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int8}  \spanOperator{=} \spanIdentifier{int8}\spanPunctuation{(}\spanCharLit{'a'}\spanPunctuation{)}   \spanComment{\# 'a' == 97'i8}
  \spanIdentifier{z}\spanPunctuation{:} \spanIdentifier{float} \spanOperator{=} \spanFloatNumber{2.5}         \spanComment{\# int(2.5) rounds down to 2}
\end{rstpre}
\rsthB{Enumerations}\label{enumerations}
A una variable de un tipo de enumeración solo se le puede asignar uno de los valores especificados de la enumeración. Estos valores son un conjunto de símbolos ordenados. Cada símbolo es mapeado a un valor entero internamente. El primer símbolo está representado en tiempo de ejecución por 0, el segundo por 1 y así sucesivamente. Por ejemplo:

\begin{rstpre}
\spanKeyword{type} \spanIdentifier{Direction} \spanOperator{=} \spanKeyword{enum}
  \spanIdentifier{north}\spanPunctuation{,} \spanIdentifier{east}\spanPunctuation{,} \spanIdentifier{south}\spanPunctuation{,} \spanIdentifier{west}

\spanKeyword{var} \spanIdentifier{x} \spanOperator{=} \spanIdentifier{south}     \spanComment{\# \symbol{96}x\symbol{96} is of type \symbol{96}Direction\symbol{96}; its value is \symbol{96}south\symbol{96}}
\spanIdentifier{echo} \spanIdentifier{x}            \spanComment{\# writes "south"}
\end{rstpre}
Todos los operadores de comparación se pueden utilizar con tipos de enumeración.

El símbolo de una enumeración se puede calificar para evitar ambigüedades: \texttt{Direction.south}.

El operador \texttt{\$} puede convertir cualquier valor de enumeración a su nombre, y el \texttt{ord} puede convertirlo a su valor entero subyacente.

Para interactuar mejor con otros lenguajes de programación, a los símbolos de enumeración se les puede asignar un valor ordinal explícito. Sin embargo, los valores ordinales debe estar en orden ascendente.

\rsthB{Ordinal types}\label{ordinal-types}
Enumeraciones, enteros, \texttt{char} y \texttt{bool} (y subranges) se llaman tipos ordinales. Los tipos ordinales tienen algunas operaciones especiales:

\begin{table}\begin{rsttab}{|X|X|X|X|X|X|X|X|X|X|}
\hline
\textbf{Operacion} & \textbf{Comentario}\\
\hline
\texttt{ord(x)} & Retorna el valor entero usado para representar \texttt{x}\\
\hline
\texttt{inc(x)} & Incrementa \texttt{x} por 1\\
\hline
\texttt{inc(x, n)} & Incrementa \texttt{x} por \texttt{n}; \texttt{n} es un entero\\
\hline
\texttt{dec(x)} & Decrementa \texttt{x} por 1\\
\hline
\texttt{dec(x, n)} & Decrementa \texttt{x} por \texttt{n}; \texttt{n} es un entero\\
\hline
\texttt{succ(x)} & Retorna el sucesor de \texttt{x}\\
\hline
\texttt{succ(x, n)} & Retorna el \texttt{n} sucesor de \texttt{x}\\
\hline
\texttt{pred(x)} & Retorna el predecesor de \texttt{x}\\
\hline
\texttt{pred(x, n)} & Retorna el \texttt{n} predecesor de \texttt{x}\\
\hline
\end{rsttab}\end{table}\rsthB{Subranges}\label{subranges}
Un tipo de subrango es un rango de valores de un entero o tipo de enumeración (el tipo base). Ejemplo:

\begin{rstpre}
\spanKeyword{type} \spanIdentifier{MySubrange} \spanOperator{=} \spanIdentifier{range}\spanPunctuation{\symbol{91}}\spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{5}\spanPunctuation{\symbol{93}}
\end{rstpre}
\texttt{MySubrange} es un Subrango de \texttt{int} que solo puede contener los valores desde \texttt{0} a \texttt{5}. Asignar cualquier otro valor a una variable de tipo \texttt{MySubrange} es un Error en tiempo de compilación o en tiempo de ejecución.

\rsthB{Arrays}\label{arrays}
Un Array es un contenedor de longitud fija simple. Cada elemento en un Array tiene el mismo tipo. El tipo de índice de la matriz puede ser cualquier tipo ordinal.

Los Array se pueden construir usando \texttt{\symbol{91}\symbol{93}}:

\begin{rstpre}
\spanKeyword{type} \spanIdentifier{IntArray} \spanOperator{=} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{5}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{\symbol{93}}   \spanComment{\# Array indexed con 0..5}

\spanKeyword{var} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{IntArray}
\spanIdentifier{x} \spanOperator{=} \spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{,} \spanDecNumber{5}\spanPunctuation{,} \spanDecNumber{6}\spanPunctuation{\symbol{93}}

\spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanIdentifier{low}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}\spanOperator{..}\spanIdentifier{high}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{x}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}
\end{rstpre}
La notación \texttt{x \symbol{91}i\symbol{93}} se usa para acceder al elemento i-th de \texttt{x}. El acceso al Array siempre se comprueba con límites (en tiempo de compilación o en tiempo de ejecución). Estos chequeos pueden ser deshabilitados a través de pragmas o invocando el compilador con \texttt{--boundChecks:off} en la línea de comando.

El operador de asignacion copia todo el contenido del Array.

\rsthB{Sequences}\label{sequences}
Las secuencias son similares al Array pero de longitud dinámica, que pueden cambiar durante el tiempo de ejecución (como las cadenas).

Las secuencias siempre se indexan con un \texttt{int} que comienza en la posición \texttt{0}.

Las secuencias pueden ser construidas por el constructor de Array \texttt{\symbol{91}\symbol{93}} en conjunción con el operador \texttt{\symbol{64}}, es decir \texttt{\symbol{64}\symbol{91}\symbol{93}}.

Ejemplo:

\begin{rstpre}
\spanKeyword{var}
  \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}}
  \spanIdentifier{x} \spanOperator{=} \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{,} \spanDecNumber{5}\spanPunctuation{,} \spanDecNumber{6}\spanPunctuation{\symbol{93}} \spanComment{\# \symbol{64} turns the array into a sequence allocated on the heap}
\end{rstpre}
Las variables de secuencia se inicializan con \texttt{\symbol{64}\symbol{91}\symbol{93}}

\rsthB{Open arrays}\label{open-arrays}
\textbf{Nota}: Openarrays solo se puede utilizar para parámetros.

A menudo, los arreglos de tamaño fijo resultan ser demasiado inflexibles; Los procedimientos deben ser capaz de manejar Array de diferentes tamaños. El \texttt{openarray} permite esto. Los Openarrays siempre se indexan con un \texttt{int} que comienza en la posición 0. Cualquier Array con un tipo de base compatible se puede pasar a un parámetro openarray.

\begin{rstpre}
\spanKeyword{var}
  \spanIdentifier{fruits}\spanPunctuation{:}   \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}}       \spanComment{\# reference to a sequence of strings that is initialized with '\symbol{64}\symbol{91}\symbol{93}'}
  \spanIdentifier{capitals}\spanPunctuation{:} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanDecNumber{3}\spanPunctuation{,} \spanIdentifier{string}\spanPunctuation{\symbol{93}}  \spanComment{\# array of strings with a fixed size}

\spanIdentifier{capitals} \spanOperator{=} \spanPunctuation{\symbol{91}}\spanStringLit{"New York"}\spanPunctuation{,} \spanStringLit{"London"}\spanPunctuation{,} \spanStringLit{"Berlin"}\spanPunctuation{\symbol{93}}   \spanComment{\# array 'capitals' allows assignment of only three elements}
\spanIdentifier{fruits}\spanOperator{.}\spanIdentifier{add}\spanPunctuation{(}\spanStringLit{"Banana"}\spanPunctuation{)}          \spanComment{\# sequence 'fruits' is dynamically expandable during runtime}
\spanIdentifier{fruits}\spanOperator{.}\spanIdentifier{add}\spanPunctuation{(}\spanStringLit{"Mango"}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{openArraySize}\spanPunctuation{(}\spanIdentifier{oa}\spanPunctuation{:} \spanIdentifier{openArray}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanIdentifier{oa}\spanOperator{.}\spanIdentifier{len}

\spanIdentifier{assert} \spanIdentifier{openArraySize}\spanPunctuation{(}\spanIdentifier{fruits}\spanPunctuation{)} \spanOperator{==} \spanDecNumber{2}     \spanComment{\# procedure accepts a sequence as parameter}
\spanIdentifier{assert} \spanIdentifier{openArraySize}\spanPunctuation{(}\spanIdentifier{capitals}\spanPunctuation{)} \spanOperator{==} \spanDecNumber{3}   \spanComment{\# but also an array type}
\end{rstpre}
El tipo openarray no puede ser anidado: Los openarrays multidimensionales no son soportados porque esto rara vez es necesario y no se puede hacer de manera eficiente.

\rsthB{Varargs}\label{varargs}
Un parámetro \texttt{varargs} es como un parámetro openarray. Sin embargo es también un medio para pasar un número variable de argumentos a un procedimiento. El compilador convierte la lista de argumentos a un Array automáticamente:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{myWriteln}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{:} \spanIdentifier{File}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{varargs}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{for} \spanIdentifier{s} \spanKeyword{in} \spanIdentifier{items}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}\spanPunctuation{:}
    \spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanIdentifier{s}\spanPunctuation{)}
  \spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanStringLit{"}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"}\spanPunctuation{)}

\spanIdentifier{myWriteln}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanStringLit{"abc"}\spanPunctuation{,} \spanStringLit{"def"}\spanPunctuation{,} \spanStringLit{"xyz"}\spanPunctuation{)}
\spanComment{\# is transformed by the compiler to:}
\spanIdentifier{myWriteln}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanPunctuation{\symbol{91}}\spanStringLit{"abc"}\spanPunctuation{,} \spanStringLit{"def"}\spanPunctuation{,} \spanStringLit{"xyz"}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\end{rstpre}
Esta transformación solo se realiza si el parámetro varargs es el ultimo parámetro en el encabezado del procedimiento. También es posible realizar conversiones de tipo en este contexto:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{myWriteln}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{:} \spanIdentifier{File}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{varargs}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{,} \spanPunctuation{\symbol{96}}\spanOperator{\$}\spanPunctuation{\symbol{96}}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{for} \spanIdentifier{s} \spanKeyword{in} \spanIdentifier{items}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}\spanPunctuation{:}
    \spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanIdentifier{s}\spanPunctuation{)}
  \spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanStringLit{"}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"}\spanPunctuation{)}

\spanIdentifier{myWriteln}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanDecNumber{123}\spanPunctuation{,} \spanStringLit{"abc"}\spanPunctuation{,} \spanFloatNumber{4.0}\spanPunctuation{)}
\spanComment{\# is transformed by the compiler to:}
\spanIdentifier{myWriteln}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanPunctuation{\symbol{91}}\spanOperator{\$}\spanDecNumber{123}\spanPunctuation{,} \spanOperator{\$}\spanStringLit{"abc"}\spanPunctuation{,} \spanOperator{\$}\spanFloatNumber{4.0}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\end{rstpre}
En este ejemplo \texttt{\$} se aplica a cualquier argumento que se pase al parámetro \texttt{a}.

\rsthB{Slices}\label{slices}
Los segmentos se parecen a los tipos de subranges en la sintaxis, pero se utilizan en una diferente contexto. Una división es solo un objeto de tipo División que contiene dos límites, \texttt{a} y \texttt{b}. Por sí mismo, un Slice no es muy útil, pero otros tipos de colección definen operadores que aceptan Slice para definir rangos.

\begin{rstpre}
\spanKeyword{var}
  \spanIdentifier{a} \spanOperator{=} \spanStringLit{"Nim is a progamming language"}
  \spanIdentifier{b} \spanOperator{=} \spanStringLit{"Slices are useless."}

\spanIdentifier{echo} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanFloatNumber{7.}\spanOperator{.}\spanDecNumber{12}\spanPunctuation{\symbol{93}} \spanComment{\# --> 'a prog'}
\spanIdentifier{b}\spanPunctuation{\symbol{91}}\spanFloatNumber{11.}\spanOperator{.\symbol{94}}\spanDecNumber{2}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanStringLit{"useful"}
\spanIdentifier{echo} \spanIdentifier{b} \spanComment{\# --> 'Slices are useful.'}
\end{rstpre}
\rsthB{Objects}\label{objects}
El tipo predeterminado para empaquetar diferentes valores juntos en una sola estructura con un nombre es el tipo Objeto. Un objeto es un Value Type, lo que significa que cuando un objeto se asigna a una nueva variable todo sus componentes también se copian.

Cada tipo de objeto \texttt{Foo} tiene un constructor \texttt{Foo(campo: valor)}, donde todos sus campos pueden ser inicializados. Los campos no especificados obtienen su valor por defecto.

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Person} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{string}
    \spanIdentifier{age}\spanPunctuation{:} \spanIdentifier{int}

\spanKeyword{var} \spanIdentifier{person1} \spanOperator{=} \spanIdentifier{Person}\spanPunctuation{(}\spanIdentifier{name}\spanPunctuation{:} \spanStringLit{"Peter"}\spanPunctuation{,} \spanIdentifier{age}\spanPunctuation{:} \spanDecNumber{30}\spanPunctuation{)}

\spanIdentifier{echo} \spanIdentifier{person1}\spanOperator{.}\spanIdentifier{name} \spanComment{\# "Peter"}
\spanIdentifier{echo} \spanIdentifier{person1}\spanOperator{.}\spanIdentifier{age}  \spanComment{\# 30}

\spanKeyword{var} \spanIdentifier{person2} \spanOperator{=} \spanIdentifier{person1} \spanComment{\# copy of person 1}

\spanIdentifier{person2}\spanOperator{.}\spanIdentifier{age} \spanOperator{+=} \spanDecNumber{14}

\spanIdentifier{echo} \spanIdentifier{person1}\spanOperator{.}\spanIdentifier{age} \spanComment{\# 30}
\spanIdentifier{echo} \spanIdentifier{person2}\spanOperator{.}\spanIdentifier{age} \spanComment{\# 44}


\spanComment{\# the order may be changed}
\spanKeyword{let} \spanIdentifier{person3} \spanOperator{=} \spanIdentifier{Person}\spanPunctuation{(}\spanIdentifier{age}\spanPunctuation{:} \spanDecNumber{12}\spanPunctuation{,} \spanIdentifier{name}\spanPunctuation{:} \spanStringLit{"Quentin"}\spanPunctuation{)}

\spanComment{\# not every member needs to be specified}
\spanKeyword{let} \spanIdentifier{person4} \spanOperator{=} \spanIdentifier{Person}\spanPunctuation{(}\spanIdentifier{age}\spanPunctuation{:} \spanDecNumber{3}\spanPunctuation{)}
\spanComment{\# unspecified members will be initialized with their default}
\spanComment{\# values. In this case it is the empty string.}
\spanIdentifier{doAssert} \spanIdentifier{person4}\spanOperator{.}\spanIdentifier{name} \spanOperator{==} \spanStringLit{""}
\end{rstpre}
Los campos de objeto que deben ser visibles desde fuera del módulo de definición tienen que estar marcados con \texttt{*}.

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Person}\spanOperator{*} \spanOperator{=} \spanKeyword{object} \spanComment{\# the type is visible from other modules}
    \spanIdentifier{name}\spanOperator{*:} \spanIdentifier{string}  \spanComment{\# the field of this type is visible from other modules}
    \spanIdentifier{age}\spanOperator{*:} \spanIdentifier{int}
\end{rstpre}
\rsthB{Tuples}\label{tuples}
Las tuplas se parecen mucho a lo que has visto de los objetos. Son tipos de valor donde el operador de asignación copia cada componente. Sin embargo, a diferencia de los tipos de objetos, los tipos de tuplas están escritos estructuralmente, lo que significa que diferentes tipos de tuplas son \emph{equivalentes} si especifican campos de el mismo tipo y del mismo nombre en el mismo orden.

El constructor \texttt{()} puede usarse para construir tuplas. El orden de los campos en el constructor deben coincidir con el orden en la tupla. Pero a diferencia de los objetos, un nombre para el tipo de tupla no puede ser utilizado aquí.

Al igual que el tipo de objeto, la notación \texttt{t.field} se usa para acceder a un campo de la tupla. Otra notación que no está disponible para objetos es \texttt{t\symbol{91}i\symbol{93}} para acceder al campo \texttt{i}. Aquí \texttt{i} debe ser un entero.

\begin{rstpre}
\spanKeyword{type}
  \spanComment{\# type representing a person:}
  \spanComment{\# A person consists of a name and an age.}
  \spanIdentifier{Person} \spanOperator{=} \spanKeyword{tuple}
    \spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{string}
    \spanIdentifier{age}\spanPunctuation{:} \spanIdentifier{int}
  
  \spanComment{\# Alternative syntax for an equivalent type.}
  \spanIdentifier{PersonX} \spanOperator{=} \spanKeyword{tuple}\spanPunctuation{\symbol{91}}\spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{,} \spanIdentifier{age}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{\symbol{93}}
  
  \spanComment{\# anonymous field syntax}
  \spanIdentifier{PersonY} \spanOperator{=} \spanPunctuation{(}\spanIdentifier{string}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{)}

\spanKeyword{var}
  \spanIdentifier{person}\spanPunctuation{:} \spanIdentifier{Person}
  \spanIdentifier{personX}\spanPunctuation{:} \spanIdentifier{PersonX}
  \spanIdentifier{personY}\spanPunctuation{:} \spanIdentifier{PersonY}

\spanIdentifier{person} \spanOperator{=} \spanPunctuation{(}\spanIdentifier{name}\spanPunctuation{:} \spanStringLit{"Peter"}\spanPunctuation{,} \spanIdentifier{age}\spanPunctuation{:} \spanDecNumber{30}\spanPunctuation{)}
\spanComment{\# Person and PersonX are equivalent}
\spanIdentifier{personX} \spanOperator{=} \spanIdentifier{person}

\spanComment{\# Create a tuple with anonymous fields:}
\spanIdentifier{personY} \spanOperator{=} \spanPunctuation{(}\spanStringLit{"Peter"}\spanPunctuation{,} \spanDecNumber{30}\spanPunctuation{)}

\spanComment{\# A tuple with anonymous fields is compatible with a tuple that has}
\spanComment{\# field names.}
\spanIdentifier{person} \spanOperator{=} \spanIdentifier{personY}
\spanIdentifier{personY} \spanOperator{=} \spanIdentifier{person}

\spanComment{\# Usually used for short tuple initialization syntax}
\spanIdentifier{person} \spanOperator{=} \spanPunctuation{(}\spanStringLit{"Peter"}\spanPunctuation{,} \spanDecNumber{30}\spanPunctuation{)}

\spanIdentifier{echo} \spanIdentifier{person}\spanOperator{.}\spanIdentifier{name} \spanComment{\# "Peter"}
\spanIdentifier{echo} \spanIdentifier{person}\spanOperator{.}\spanIdentifier{age}  \spanComment{\# 30}

\spanIdentifier{echo} \spanIdentifier{person}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}} \spanComment{\# "Peter"}
\spanIdentifier{echo} \spanIdentifier{person}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{\symbol{93}} \spanComment{\# 30}

\spanComment{\# You don't need to declare tuples in a separate type section.}
\spanKeyword{var} \spanIdentifier{building}\spanPunctuation{:} \spanKeyword{tuple}\spanPunctuation{\symbol{91}}\spanIdentifier{street}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{,} \spanIdentifier{number}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{\symbol{93}}
\spanIdentifier{building} \spanOperator{=} \spanPunctuation{(}\spanStringLit{"Rue del Percebe"}\spanPunctuation{,} \spanDecNumber{13}\spanPunctuation{)}
\spanIdentifier{echo} \spanIdentifier{building}\spanOperator{.}\spanIdentifier{street}

\spanComment{\# The following line does not compile, they are different tuples!}
\spanComment{\#person = building}
\spanComment{\# --> Error: type mismatch: got (tuple\symbol{91}street: string, number: int\symbol{93})}
\spanComment{\#     but expected 'Person'}
\end{rstpre}
Aunque no es necesario declarar un tipo para que una tupla lo use, las tuplas creadas con diferentes nombres de campo serán considerados objetos diferentes a pesar de tener los mismos tipos de campo.

Los campos de tuplas son siempre públicos, no necesitan ser explícitamente marcados para ser exportados, a diferencia de por ejemplo, los campos en un tipo de objeto.

\rsthA{Modulos}\label{modulos}
Nim admite la división de un programa en partes con un concepto de módulo. Cada módulo está en su propio archivo. Un módulo puede acceder a los símbolos de otro módulo utilizando la instrucción \texttt{import}. Sólo los símbolos de nivel superior que están marcados con un asterisco \texttt{*} se exportan.

\begin{rstpre}
\spanComment{\# Modulo A}
\spanKeyword{var}
  \spanIdentifier{x}\spanOperator{*}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}} \spanOperator{=}
  \spanComment{\# allocate a new sequence:}
  \spanIdentifier{newSeq}\spanPunctuation{(}\spanIdentifier{result}\spanPunctuation{,} \spanIdentifier{len}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}\spanPunctuation{)}
  \spanComment{\# multiply two int sequences:}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}\spanOperator{-}\spanDecNumber{1}\spanPunctuation{:} \spanIdentifier{result}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}} \spanOperator{*} \spanIdentifier{b}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}

\spanKeyword{when} \spanIdentifier{isMainModule}\spanPunctuation{:}
  \spanComment{\# test the new \symbol{96}\symbol{96}*\symbol{96}\symbol{96} operator for sequences:}
  \spanIdentifier{assert}\spanPunctuation{(}\spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{\symbol{93}} \spanOperator{*} \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{\symbol{93}} \spanOperator{==} \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{,} \spanDecNumber{9}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\end{rstpre}
El módulo anterior exporta \texttt{x} y \texttt{*}, pero no \texttt{y}.

Las instrucciones de nivel superior de un módulo se ejecutan al inicio del programa. Esto se puede usar para inicializar estructuras de datos complejas, por ejemplo.

Cada módulo tiene una constante mágica especial \texttt{isMainModule}, que es verdadera si el módulo se compila como el archivo principal. Esto es muy útil para incrustar pruebas dentro de el módulo como se muestra en el ejemplo anterior.

\rsthB{Excluding symbols}\label{excluding-symbols}
La declaración normal \texttt{import} traerá todos los símbolos exportados. Estos pueden estar limitados por nombres de símbolos que deberían excluirse con el calificador \texttt{except}:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{mymodule} \spanKeyword{except} \spanIdentifier{y}
\end{rstpre}
\rsthB{From statement}\label{from-statement}
Ya hemos visto la simple declaración \texttt{import} que solo importa todos símbolos exportados. Una alternativa que solo importa los símbolos listados es \texttt{from import}:

\begin{rstpre}
\spanKeyword{from} \spanIdentifier{mymodule} \spanKeyword{import} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{,} \spanIdentifier{z}
\end{rstpre}
La declaración \texttt{from} también puede forzar la calificación del espacio de nombres en símbolos, por lo que los símbolos están disponibles, pero necesitan ser calificados para ser utilizados.

\begin{rstpre}
\spanKeyword{from} \spanIdentifier{mymodule} \spanKeyword{import} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{,} \spanIdentifier{z}

\spanIdentifier{x}\spanPunctuation{(}\spanPunctuation{)}           \spanComment{\# use x without any qualification}
\end{rstpre}
\begin{rstpre}
\spanKeyword{from} \spanIdentifier{mymodule} \spanKeyword{import} \spanKeyword{nil}

\spanIdentifier{mymodule}\spanOperator{.}\spanIdentifier{x}\spanPunctuation{(}\spanPunctuation{)}  \spanComment{\# must qualify x with the module name as prefix}

\spanIdentifier{x}\spanPunctuation{(}\spanPunctuation{)}           \spanComment{\# using x here without qualification is a compile error}
\end{rstpre}
Dado que los nombres de los módulos son generalmente largos para ser descriptivos, también puede definir un alias más corto para usar cuando califiques símbolos.

\begin{rstpre}
\spanKeyword{from} \spanIdentifier{mymodule} \spanKeyword{as} \spanIdentifier{m} \spanKeyword{import} \spanKeyword{nil}
\spanIdentifier{m}\spanOperator{.}\spanIdentifier{x}\spanPunctuation{(}\spanPunctuation{)}         \spanComment{\# m is aliasing mymodule}
\end{rstpre}
\rsthB{Include statement}\label{include-statement}
La declaración \texttt{include} hace algo fundamentalmente diferente a importar un módulo: Simplemente incluye el contenido de un archivo. \texttt{include} es útil para dividir un módulo grande en varios archivos:

\begin{rstpre}
\spanKeyword{include} \spanIdentifier{fileA}\spanPunctuation{,} \spanIdentifier{fileB}\spanPunctuation{,} \spanIdentifier{fileC}
\end{rstpre}
\textbf{FIN}

\begin{itemize}\item Entonces, hasta aqui hemos terminado con lo básico.
\end{itemize}



\end{document}
